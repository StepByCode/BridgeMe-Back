name: Notion Sync (tasks schema)

on:
  workflow_dispatch:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, reopened, closed, closed]

permissions:
  contents: read
  issues: read

jobs:
  sync_to_notion:
    runs-on: ubuntu-latest
    concurrency:
      group: notion-sync-${{ github.event.issue.number || 'manual' }}
      cancel-in-progress: false

    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install deps
        run: npm install @notionhq/client

      - name: Sync GitHub Issues to Notion (tasks schema)
        env:
          # --- 必須シークレット ---
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}           # Notion Internal Integration (secret_...)
          NOTION_DATABASE: ${{ secrets.NOTION_DATABASE }}     # 32桁DB ID
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}           # 既定で入ってるやつ

          # --- 任意：固定アサイン（People列）---
          # 例: Ryosuke.Kido -> 190d872b-594c-812a-a3c6-000295d6d2a7
          NOTION_ASSIGNEE_ID: ${{ secrets.NOTION_ASSIGNEE_ID }}

          # ラベル→In Progress 判定のキーワード（カンマ区切りで拡張可）
          INPROGRESS_KEYS: in progress,wip,doing,progress,working

          # ラベル名の正規化用（GitHub側の小文字名=Notion側の表示名）
          LABEL_MAP_JSON: >
            {
              "bug":"Bug",
              "enhancement":"Enhancement",
              "documentation":"Documentation",
              "feature request":"Feature request",
              "help wanted":"Help wanted",
              "question":"Question",
              "good first issue":"Good first issue",
              "high priority":"High priority",
              "low priority":"Low priority"
            }

          # コンテキスト
          REPO: ${{ github.repository }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          node - <<'NODE'
          const { Client } = require("@notionhq/client");
          const fetch = global.fetch;

          const notion = new Client({ auth: process.env.NOTION_TOKEN });
          const DB_ID = process.env.NOTION_DATABASE;
          const [owner, repo] = process.env.REPO.split("/");
          const ASSIGNEE_ID = process.env.NOTION_ASSIGNEE_ID || null;

          const ghBase = 'https://api.github.com';
          const ghHeaders = {
            'Authorization': `token ${process.env.GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28'
          };

          // ---- utils
          const cap = (s,n=1900)=> (s??'').slice(0,n);
          const rich = (s)=> s ? [{type:'text', text:{content: cap(s)}}] : [];
          const toDate = (iso) => iso ? { start: new Date(iso).toISOString() } : null;

          // ラベル正規化
          const LABEL_MAP = new Map(Object.entries(JSON.parse(process.env.LABEL_MAP_JSON || "{}")));
          const normalizeLabels = (labels=[]) => {
            const out = [];
            for (const l of labels) {
              const key = String(l.name||'').trim().toLowerCase();
              if (LABEL_MAP.has(key)) out.push({ name: LABEL_MAP.get(key) });
            }
            return out;
          };

          // 進行中判定キーワード
          const INPROG_KEYS = String(process.env.INPROGRESS_KEYS || "in progress,wip,doing,progress,working")
            .split(",").map(s => s.trim().toLowerCase()).filter(Boolean);
          const isInProgressByLabels = (labels=[]) => {
            const set = new Set(labels.map(l => String(l.name||'').toLowerCase()));
            return INPROG_KEYS.some(k => set.has(k));
          };

          // Status（Todo / In Progress / Done）
          const mapStatus = (issue) => {
            if ((issue.state||'').toLowerCase() === 'closed') return 'Done';
            if (isInProgressByLabels(issue.labels)) return 'In Progress';
            return 'Todo';
          };

          // ---- DBメタ取得
          let DB_PROPS = null;
          async function ensureDbProps() {
            if (DB_PROPS) return DB_PROPS;
            const db = await notion.databases.retrieve({ database_id: DB_ID });
            DB_PROPS = new Set(Object.keys(db.properties || {}));
            return DB_PROPS;
          }
          const hasProp = (name)=> DB_PROPS && DB_PROPS.has(name);

          // ---- Upsert
          async function upsertIssue(issue) {
            await ensureDbProps();

            // 書き込み候補（存在する列だけ投げる）
            const candidate = {
              "Task":         { title: [{ type:"text", text: { content: cap(issue.title||'') } }] },
              "Status":       { select: { name: mapStatus(issue) } },
              "Assignee":     ASSIGNEE_ID ? { people: [{ id: ASSIGNEE_ID }] } : undefined,
              "Due":          { date: null },
              "Labels":       { multi_select: normalizeLabels(issue.labels) },
              "URL":          { url: issue.html_url },
              "Created":      { date: toDate(issue.created_at) },
              "Updated":      { date: toDate(issue.updated_at) },
              "Author":       { rich_text: rich(issue.user?.login) },
              "Repository":   { rich_text: rich(repo) },
              "Issue Number": { number: issue.number },
              "github id":    { number: issue.id }, // 無ければ後で諦める
            };

            const props = {};
            for (const [k,v] of Object.entries(candidate)) {
              if (v === undefined) continue;
              if (hasProp(k)) props[k] = v;
            }

            // 検索キー：① github id、② Issue Number + Repository、③作成一択
            let existing = null;
            if (hasProp("github id")) {
              existing = await notion.databases.query({
                database_id: DB_ID,
                filter: { property: "github id", number: { equals: issue.id } },
                page_size: 1
              });
            } else if (hasProp("Issue Number") && hasProp("Repository")) {
              existing = await notion.databases.query({
                database_id: DB_ID,
                filter: {
                  and: [
                    { property: "Issue Number", number: { equals: issue.number } },
                    { property: "Repository",   rich_text: { equals: repo } }
                  ]
                },
                page_size: 1
              });
            } else {
              existing = { results: [] };
            }

            if (existing.results.length) {
              const pageId = existing.results[0].id;
              await notion.pages.update({ page_id: pageId, properties: props });
              console.log(`Updated #${issue.number} -> ${pageId}`);
            } else {
              await notion.pages.create({ parent: { database_id: DB_ID }, properties: props });
              console.log(`Created #${issue.number}`);
            }
          }

          // ---- GitHub API（手動同期）
          async function getAllIssues() {
            const res = await fetch(`${ghBase}/repos/${owner}/${repo}/issues?state=all&per_page=100`, { headers: ghHeaders });
            if (!res.ok) throw new Error(`List issues failed: ${res.status}`);
            return await res.json();
          }

          // ---- main
          (async () => {
            try {
              if (process.env.EVENT_NAME === 'issues') {
                const payload = require(process.env.GITHUB_EVENT_PATH);
                if (!payload.issue) throw new Error("No issue payload");
                if (payload.issue.pull_request) { console.log("Skip PR"); process.exit(0); }
                await upsertIssue(payload.issue);
              } else {
                const issues = await getAllIssues();
                for (const issue of issues) {
                  if (issue.pull_request) continue;
                  await upsertIssue(issue);
                }
              }
              console.log("Done.");
            } catch (e) {
              console.error(e);
              process.exit(1);
            }
          })();
          NODE
