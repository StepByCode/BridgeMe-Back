name: Notion Sync (tasks schema, status-aware)

on:
  workflow_dispatch:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, reopened, closed]

permissions:
  contents: read
  issues: read

jobs:
  sync_to_notion:
    runs-on: ubuntu-latest
    concurrency:
      group: notion-sync-${{ github.event.issue.number || 'manual' }}
      cancel-in-progress: false

    steps:
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install deps
        run: npm install @notionhq/client

      - name: Sync GitHub Issues to Notion (status-aware)
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE: ${{ secrets.NOTION_DATABASE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NOTION_ASSIGNEE_ID: ${{ secrets.NOTION_ASSIGNEE_ID }} # 例: 190d872b-594c-812a-a3c6-000295d6d2a7
          REPO: ${{ github.repository }}
          EVENT_NAME: ${{ github.event_name }}
          INPROGRESS_KEYS: in progress,wip,doing,progress,working
          LABEL_MAP_JSON: >
            {
              "bug":"Bug",
              "enhancement":"Enhancement",
              "documentation":"Documentation",
              "feature request":"Feature request",
              "help wanted":"Help wanted",
              "question":"Question",
              "good first issue":"Good first issue",
              "high priority":"High priority",
              "low priority":"Low priority"
            }
        run: |
          node - <<'NODE'
          const { Client } = require("@notionhq/client");
          const fetch = global.fetch;

          const notion = new Client({ auth: process.env.NOTION_TOKEN });
          const DB_ID = process.env.NOTION_DATABASE;
          const [owner, repo] = process.env.REPO.split("/");
          const ASSIGNEE_ID = process.env.NOTION_ASSIGNEE_ID || null;

          const ghBase = 'https://api.github.com';
          const ghHeaders = {
            'Authorization': `token ${process.env.GITHUB_TOKEN}`,
            'Accept': 'application/vnd.github+json',
            'X-GitHub-Api-Version': '2022-11-28'
          };

          const cap = (s,n=1900)=> (s??'').slice(0,n);
          const rich = (s)=> s ? [{type:'text', text:{content: cap(s)}}] : [];
          const toDate = (iso) => iso ? { start: new Date(iso).toISOString() } : null;

          const LABEL_MAP = new Map(Object.entries(JSON.parse(process.env.LABEL_MAP_JSON || "{}")));
          const normalizeLabels = (labels=[]) => {
            const out = [];
            for (const l of labels) {
              const key = String(l.name||'').trim().toLowerCase();
              if (LABEL_MAP.has(key)) out.push({ name: LABEL_MAP.get(key) });
            }
            return out;
          };

          const INPROG_KEYS = String(process.env.INPROGRESS_KEYS || "in progress,wip,doing,progress,working")
            .split(",").map(s => s.trim().toLowerCase()).filter(Boolean);
          const isInProgressByLabels = (labels=[]) => {
            const set = new Set(labels.map(l => String(l.name||'').toLowerCase()));
            return INPROG_KEYS.some(k => set.has(k));
          };
          const mapStatusName = (issue) => {
            if ((issue.state||'').toLowerCase() === 'closed') return 'Done';
            if (isInProgressByLabels(issue.labels)) return 'In Progress';
            return 'Todo';
          };

          // ---- DBメタ：各プロパティの type を取得（status/select を識別）
          let DB_PROP_TYPES = null;
          async function loadDbPropTypes() {
            if (DB_PROP_TYPES) return DB_PROP_TYPES;
            const db = await notion.databases.retrieve({ database_id: DB_ID });
            DB_PROP_TYPES = {};
            for (const [name, def] of Object.entries(db.properties || {})) {
              DB_PROP_TYPES[name] = def.type; // e.g. 'title' | 'rich_text' | 'status' | 'select' | ...
            }
            return DB_PROP_TYPES;
          }
          const hasProp = (name)=> DB_PROP_TYPES && (name in DB_PROP_TYPES);
          const typeOf = (name)=> DB_PROP_TYPES ? DB_PROP_TYPES[name] : undefined;

          // Statusプロパティを型に合わせて組み立て
          function buildStatusProp(statusName) {
            const t = typeOf("Status");
            if (t === "status") return { status: { name: statusName } };
            if (t === "select") return { select: { name: statusName } };
            // どちらでもない場合は未設定で返す（存在しない列）
            return undefined;
          }

          async function upsertIssue(issue) {
            await loadDbPropTypes();

            const candidate = {
              "Task":         hasProp("Task")         ? { title: [{ type:"text", text: { content: cap(issue.title||'') } }] } : undefined,
              "Status":       hasProp("Status")       ? buildStatusProp(mapStatusName(issue)) : undefined,
              "Assignee":     (hasProp("Assignee") && ASSIGNEE_ID) ? { people: [{ id: ASSIGNEE_ID }] } : undefined,
              "Due":          hasProp("Due")          ? { date: null } : undefined,
              "Labels":       hasProp("Labels")       ? { multi_select: normalizeLabels(issue.labels) } : undefined,
              "URL":          hasProp("URL")          ? { url: issue.html_url } : undefined,
              "Created":      hasProp("Created")      ? { date: toDate(issue.created_at) } : undefined,
              "Updated":      hasProp("Updated")      ? { date: toDate(issue.updated_at) } : undefined,
              "Author":       hasProp("Author")       ? { rich_text: rich(issue.user?.login) } : undefined,
              "Repository":   hasProp("Repository")   ? { rich_text: rich(repo) } : undefined,
              "Issue Number": hasProp("Issue Number") ? { number: issue.number } : undefined,
              "github id":    hasProp("github id")    ? { number: issue.id } : undefined,
            };

            const props = {};
            for (const [k,v] of Object.entries(candidate)) {
              if (v !== undefined) props[k] = v;
            }

            // 検索キー：① github id、② Issue Number + Repository、③新規作成
            let existing = null;
            if (hasProp("github id")) {
              existing = await notion.databases.query({
                database_id: DB_ID,
                filter: { property: "github id", number: { equals: issue.id } },
                page_size: 1
              });
            } else if (hasProp("Issue Number") && hasProp("Repository")) {
              // Repository が rich_text で equals 比較できる前提
              existing = await notion.databases.query({
                database_id: DB_ID,
                filter: {
                  and: [
                    { property: "Issue Number", number: { equals: issue.number } },
                    { property: "Repository",   rich_text: { equals: repo } }
                  ]
                },
                page_size: 1
              });
            } else {
              existing = { results: [] };
            }

            if (existing.results.length) {
              const pageId = existing.results[0].id;
              await notion.pages.update({ page_id: pageId, properties: props });
              console.log(`Updated #${issue.number} -> ${pageId}`);
            } else {
              await notion.pages.create({ parent: { database_id: DB_ID }, properties: props });
              console.log(`Created #${issue.number}`);
            }
          }

          async function getAllIssues() {
            const res = await fetch(`${ghBase}/repos/${owner}/${repo}/issues?state=all&per_page=100`, { headers: ghHeaders });
            if (!res.ok) throw new Error(`List issues failed: ${res.status}`);
            return await res.json();
          }

          (async () => {
            try {
              if (process.env.EVENT_NAME === 'issues') {
                const payload = require(process.env.GITHUB_EVENT_PATH);
                if (!payload.issue) throw new Error("No issue payload");
                if (payload.issue.pull_request) { console.log("Skip PR"); process.exit(0); }
                await upsertIssue(payload.issue);
              } else {
                const issues = await getAllIssues();
                for (const issue of issues) {
                  if (issue.pull_request) continue;
                  await upsertIssue(issue);
                }
              }
              console.log("Done.");
            } catch (e) {
              console.error(e);
              process.exit(1);
            }
          })();
          NODE
